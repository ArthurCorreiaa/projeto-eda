# Projeto de Estrutura de Dados

## Resumo da proposta

Comparar a eficiência das estruturas de dados lineares Array, ArrayList, LinkedList, Stack, Queue e Deque nas linguagens de programação Python, Java e C++ nos sistemas operacionais Windows 11, Fedora 41 e Ubuntu 24.04. A comparação será referente à eficiência de tempo, eficiência de memória e limites de tamanhos de entrada de cada algoritmo executando funções de inserção, remoção e busca.

## Desenvolvimento da proposta

### Ideia do projeto

A ideia do projeto é a) implementar os algoritmos referentes às estruturas de dados Array, ArrayList, LinkedList, Stack, Queue e Deque nas linguagens de programação Python, Java e C++. Em seguida, b) executar funções de inserção, remoção e busca nos algoritmos implementados, medindo a eficiência de tempo, eficiência de memória e limites de tamanhos de entrada. A partir daí, elaborar um c) relatório com os resultados obtidos e explicações a respeito.

### Motivação

A motivação do projeto é a) subsidiar a disciplina de Estrutura de Dados e Algoritmos com material complementar e b) fixar e expandir o conteúdo aprendido ao decorrer do curso, com tópicos não estudados diretamente ou estudados de maneira mais superficial.

### Entrega

A entrega do trabalho envolverá a disponibilização de a) código-fonte dos algoritmos implementados nas diferentes linguagens de programação, b) gráficos gerados a respeito dos desempenhos de cada combinação “estrutura de dado + linguagem + sistema operacional” e c) relatório com os resultados obtidos e explicações a respeito.

## Planejamento da proposta

### Etapa 1: estudar estruturas de dados

Nesta etapa, estudaremos a teoria a respeito das estruturas de dados escolhidas para subsidiar e delimitar as implementações.

### Etapa 2: implementar e testar estruturas de dados

Nesta etapa, implementamos as estruturas de dados escolhidas e já estudadas nas diferentes linguagens de programação e faremos testes.

### Etapa 3: gerar os dados de entrada, de saída e plotar gráficos

Nesta etapa, geramos os dados de entrada que alimentarão os algoritmos, a partir de Shell ou formas alternativas, iniciando com entradas pequenas e aumentando exponencialmente até o limite de cada algoritmo.

A partir desses dados de entrada, executaremos os algoritmos e colheremos os dados de saída, em forma de a) monitoramento dos tempos de execução com algoritmos nas próprias linguagens, b) monitoramento da memória usada para execução, por meio de perfilamento de memória e c) observação das capacidades de volumes de entrada.

Por fim, com os dados relativos às saídas em mãos, geramos os gráficos comparativos sobre consumo de memória, de tempo e capacidades de volumes de entrada.

### Etapa 4: fazer relatório

Nesta etapa, analisaremos os dados coletados e agregaremos as explicações em um relatório.

